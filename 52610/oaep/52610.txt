Q.1 Consider an example where N = 551, e = 5, d = 101 and c = 243.  Using
    your own words, briefly explain and illustrate the working principle of
    this attack (i.e., how and why it works).

Answer:
    N = 551
    e = 5
    d = 101
    c = 243

    k = ceil(log(256)N) = 2 , the byte length of N
    B = 2^(8*(k-1)) = 2^8 = 256

    The attacker chooses a multiple f and sends f to the Oracle. The oracle
    computes f^e * c (mod N) and returns whether the result is "< B" or
    ">= B". The previous ciphertext corresponds to the plaintext f*m.
    ((f^e)*c)^d = f^(e*d) * c^d = f * m (mod N)
    The oracle indicates if f*m is in the range [0, B) or (B, n) modulo N,
    providing a mathematical relationship about m that reduces the range in
    which it must lie.

    Step 1:
    Try multiples of 2,4,.. 2^i.... until the oracle returns ">= B".

    f_1 = 2
    Send f_1 to Oracle, the Oracle returns "< B" {f_1^e * c (mod N) = 61}
    Increase f_1 = 4
    Send f_1 to Oracle, the Oracle returns ">= B" {f_1^e * c (mod N) = 331}

    Step 2:
    Start with a multiple f_2 such that f_2*m is less than N+B for the
    maximum possible m. Keep increasing the multiple until the Oracle returns
    "< B"

    f_2 = floor( (N+B) / B) * (f_1 / 2)
    f_2 = floor( (551 + 256) / 256) * (4 / 2)
    f_2 = floor( 807 / 256 ) * 2
    f_2 = floor( 3.15) * 2
    f_2 = 3 * 2
    f_2 = 6

    Send f_2 to the Oracle. {Compute f_2^e * c mod N}
    The oracle returns "< B" {f_2^e * c mod N = 189}

    => f_2 * m is in [N, N+N)

    As f_2 increases , the lower bound of f_2 * m increases.

    Step 3:
    Try multiples f_3 that give a range for f_3 * about 2B integers wide.
    Each oracle response will half the range back to a width of about B
    integers, so the next multiple is about twi the previous value.

    f_2 * m is in [N, N+B)
    Dividing the above line by f_2, we obtain the range in which m lies.
    m is in [mmin ,mmax) where

    mmin = ceil(N / f_2)
    mmin = 92

    mmax = floor( (N+B) / f_2 )
    mmax = 134

    Choose multiple f_tmp such that the width of f_tmp * m id approximately
    2B.
    f_tmp = floor(2*B / (mmax-mmin))
    f_tmp = 12
    This values is twice the value of f_2

    Select a boundary point i*N+B
    i = floor(f_tmp * mmin / N)
    i = 2

    f_3 = ceil( i * N / mmin )
    f_3 = 12

    Try f_3 with the Oracle. The oracle returns ">=B"
    {f_3^e * c mod N = 538}
    mmin = ceil((i*N + B) / f_3)
    mmin = 114
    The range in which m lies is now half the initial length.

    We keep recalculating the mmin and mmax values depending on the Oracles's
    response. When mmin = mmax, we have found our answer.

    f_tmp = 25
    i = 5
    f_3 = 25
    Send f_3 to the Oracle, the Oracle returns "< B".
    {f_3^e * c mod N = 75}
    mmax = 120

    f_tmp = 85
    i = 17
    f_3 = 83
    Send f_3 to the Oracle, the Oracle returns ">= B"
    {f_3^e * c mod N = 336}
    mmin = 116

    f_tmp = 128
    i = 26
    f_3 = 124
    Send f_3 to the Oracle, the Oracle returns "< B".
    {f_3^e * c mod N = 7}
    mmax = 117

    f_tmp = 512
    i = 107
    f_3 = 509
    Send f_3 to the Oracle, the Oracle returns ">= B".
    {f_3^e * c mod N = 543}
    mmin = 117

    mmin = mmax so we stop. The range of values that m can have has been
    reduced to only one value 117.


Q.2 To prevent the attack, the vendor suggests altering the software: the
    idea is that no matter what error occurs, the same error code will be
    produced.  Explain whether (and why, or why not) this change alone is
    sufficient.
Q.3 Ignoring the use of countermeasures, carefully detail any situations
    where your implementation of this attack could fail; given more time,
    what could you do to resolve this?
Q.5 Explain how the concept of plaintext awareness relates to this attack.
